using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Text;
using Pentadome.CSharp.SourceGenerators.ObservableObjects.UserAttributes;
using Pentadome.CSharp.SourceGenerators.ObservableObjects;

namespace Pentadome.CSharp.SourceGenerators
{
    [Generator]
    public sealed class ObservableObjectSourceGenerator : ISourceGenerator
    {
        private INamedTypeSymbol? _observableObjectAttributeSymbol;

        private INamedTypeSymbol? _propertyAttributeAttributeSymbol;

        private INamedTypeSymbol? _iNotifyChangedSymbol;

        private INamedTypeSymbol? _iNotifyChangingSymbol;

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new ObservableObjectSyntaxReceiver());

#if DEBUGSOURCEGENERATOR
            if (!Debugger.IsAttached)
            {
                Debugger.Launch();
            }
#endif
        }

        public void Execute(GeneratorExecutionContext context)
        {
#if DEBUGSOURCEGENERATOR
            if (!Debugger.IsAttached)
            {
                Debugger.Launch();
            }
#endif

            Attributes.AddAttributesToSource(context);

            if (context.SyntaxReceiver is not ObservableObjectSyntaxReceiver syntaxReceiver)
                return;

            var cSharpCompilation = (CSharpCompilation)context.Compilation;
            var options = (cSharpCompilation.SyntaxTrees[0].Options as CSharpParseOptions)!;
            cSharpCompilation = EnsureSymbolsSet(cSharpCompilation, options);

            foreach (var symbolsGroup in GetFieldSymbols(cSharpCompilation, syntaxReceiver.CandidateClasses).GroupBy(x => x.ContainingType))
            {
                var classDiagnostics = ClassValidator.Validate(symbolsGroup.Key);
                if (classDiagnostics.Count > 0)
                {
                    foreach (var diagnostic in classDiagnostics)
                    {
                        context.ReportDiagnostic(diagnostic);
                    }
                }
                else
                {
                    var classSourceString = ProcessClass(symbolsGroup.Key, symbolsGroup.AsEnumerable());
                    context.AddSource($"{symbolsGroup.Key.Name}_observable", SourceText.From(classSourceString, Encoding.UTF8));
                }
            }
        }

        private IEnumerable<IFieldSymbol> GetFieldSymbols(CSharpCompilation compilation, IEnumerable<ClassDeclarationSyntax> classDeclarations)
        {
            foreach (var classDeclaration in classDeclarations)
            {
                var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
                var classSymbol = model.GetDeclaredSymbol(classDeclaration)!;

                if (!classSymbol.GetAttributes().Any(x => x.AttributeClass!.Equals(_observableObjectAttributeSymbol, SymbolEqualityComparer.Default)))
                    continue;

                foreach (var field in classSymbol.GetMembers().Where(x => x.Kind == SymbolKind.Field).Cast<IFieldSymbol>())
                {
                    yield return field;
                }
            }
        }

        //[MemberNotNull(nameof(_attributeTypeSymbol), nameof(_iNotifyChangedSymbol), nameof(_iNotifyChangingSymbol))]
        // Attribute not supported in netstandard 2.0
        private CSharpCompilation EnsureSymbolsSet(CSharpCompilation cSharpCompilation, CSharpParseOptions options)
        {
            var compilation = Attributes.AddAttributesToSyntax(cSharpCompilation, options);

            // get the newly bound attribute, INotifyPropertyChanging and INotifyPropertyChanged
            _observableObjectAttributeSymbol ??= compilation.GetTypeByMetadataNameOrThrow(Attributes._fullObservableObjectAttributeName);
            _propertyAttributeAttributeSymbol ??= compilation.GetTypeByMetadataNameOrThrow(Attributes._fullPropertyAttributeAttributeName);
            _iNotifyChangedSymbol ??= compilation.GetTypeByMetadataNameOrThrow("System.ComponentModel.INotifyPropertyChanged");
            _iNotifyChangingSymbol ??= compilation.GetTypeByMetadataNameOrThrow("System.ComponentModel.INotifyPropertyChanging");
            return compilation;
        }

        private string ProcessClass(INamedTypeSymbol classSymbol, IEnumerable<IFieldSymbol> fields)
        {
            string namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // begin building the generated source
            var source = new StringBuilder($@"
// The following was generated by a Source Generator.
using System;
namespace {namespaceName}
{{
    public partial class {classSymbol.Name} : {_iNotifyChangedSymbol!.ToDisplayString()}, {_iNotifyChangingSymbol!.ToDisplayString()}
    {{
");

            // if the class doesn't implement INotifyPropertyChanged already, add it
            if (!classSymbol.Interfaces.Contains(_iNotifyChangedSymbol))
            {
                source.AppendLine("        public event System.ComponentModel.PropertyChangedEventHandler PropertyChanged;");
            }
            // if the class doesn't implement INotifyPropertyChanging already, add it
            if (!classSymbol.Interfaces.Contains(_iNotifyChangingSymbol))
            {
                source.AppendLine("        public event System.ComponentModel.PropertyChangingEventHandler PropertyChanging;");
            }

            // create properties for each field 
            foreach (var fieldSymbol in fields)
            {
                ProcessField(source, fieldSymbol);
            }

            source.Append("\r\n    }\r\n}");
            return source.ToString();
        }

        private void ProcessField(StringBuilder source, IFieldSymbol fieldSymbol)
        {
            // get the name and type of the field
            string fieldName = fieldSymbol.Name;
            ITypeSymbol fieldType = fieldSymbol.Type;

            string propertyName = getPropertyName(fieldName);
            if (propertyName.Length == 0 || propertyName == fieldName)
            {
                //TODO: issue a diagnostic that we can't process this field
                return;
            }
            var propertyAttributes = GetPropertyAttributes(fieldSymbol).ToList();

            source.Append(@"
        partial void On").Append(propertyName).Append(@"Changed();

");
            foreach (var attribute in propertyAttributes)
            {
                source.Append("        [").Append(attribute.ToFullString()).AppendLine("]");
            }

        source.Append("        public ").Append(fieldType).Append(' ').Append(propertyName).Append(@"
        {
            get => this.").Append(fieldName).Append(@";
            set
            {
                this.PropertyChanging?.Invoke(this, new System.ComponentModel.PropertyChangingEventArgs(nameof(").Append(propertyName).Append(@")));
                this.").Append(fieldName).Append(" = value;").Append(@"
                this.").Append("On").Append(propertyName).Append("Changed();").Append(@"
                this.PropertyChanged?.Invoke(this, new System.ComponentModel.PropertyChangedEventArgs(nameof(").Append(propertyName).Append(@")));
            }
        }
");

            static string getPropertyName(string fieldName)
            {
                fieldName = fieldName.TrimStart('_');
                if (fieldName.Length == 0)
                    return string.Empty;

                if (fieldName.Length == 1)
                    return fieldName.ToUpper();

                return char.ToUpperInvariant(fieldName[0]) + fieldName.Substring(1);
            }
        }

        private IEnumerable<AttributeSyntax> GetPropertyAttributes(IFieldSymbol fieldSymbol)
        {
            foreach (var attribute in fieldSymbol.GetAttributes().Where(x => x.AttributeClass!.Equals(_propertyAttributeAttributeSymbol, SymbolEqualityComparer.Default)))
            {
                var typeArgument = GetPropertyAttributeType(attribute);

                var attributeSyntax = attribute.ApplicationSyntaxReference!.GetSyntax() as AttributeSyntax;

                var newAttributeArgumentsSyntaxes = GetConstructorArguments(attributeSyntax!).Union(GetNamedPropertyArguments(attributeSyntax!));

                var newAttributeArgumentList = SyntaxFactory.AttributeArgumentList(SyntaxFactory.SeparatedList(newAttributeArgumentsSyntaxes));

                yield return SyntaxFactory.Attribute(SyntaxFactory.ParseName(typeArgument), newAttributeArgumentList);
            }

            

            static string GetPropertyAttributeType(AttributeData propetyAttributeAttributeData)
            {
                var constructorArguments = propetyAttributeAttributeData.ConstructorArguments;
                return (constructorArguments[0].Value as INamedTypeSymbol)!.ToDisplayString();
            }

            static IEnumerable<AttributeArgumentSyntax> GetConstructorArguments(AttributeSyntax propertyAttributeAttributeSyntax)
            {
                return propertyAttributeAttributeSyntax!.ArgumentList!.Arguments.Skip(1).Where(x => x.NameEquals is null);
            }

            static IEnumerable<AttributeArgumentSyntax> GetNamedPropertyArguments(AttributeSyntax propertyAttributeAttributeSyntax)
            {
                var arguments = propertyAttributeAttributeSyntax.ArgumentList!.Arguments.Where(x => x.NameEquals is not null);

                var argumentsById = arguments.ToLookup(x =>
                {
                    var nameEquals = x.NameEquals!.Name.Span.ToString();
                    var namedArgumentId = nameEquals[Attributes._attributeNamedPropertyStartIdentifier.Length];
                    return Convert.ToInt32(namedArgumentId);
                });

                for (byte i = 1; i != 5; i++)
                {
                    var namedPropertyData = argumentsById[i];

                    if (!namedPropertyData.Any())
                        continue;

                    var namedPropertyNameSyntax = namedPropertyData.FirstOrDefault(x => x.NameEquals!.Name.Span.ToString().EndsWith(Attributes._attributeNamedPropertyNameIdentifier));
                    var namedPropertyValueSyntax = namedPropertyData.FirstOrDefault(x => x.NameEquals!.Name.Span.ToString().EndsWith(Attributes._attributeNamedPropertyValueIdentifier));

                    var namedPropertyName = namedPropertyNameSyntax.Expression.Span.ToString();
                    var namedPropertyValueExpression = namedPropertyValueSyntax.Expression;

                    yield return SyntaxFactory.AttributeArgument(
                        SyntaxFactory.NameEquals(SyntaxFactory.IdentifierName(namedPropertyName)),
                        null,
                        namedPropertyValueExpression);
                }
            }
        }
    }
}
